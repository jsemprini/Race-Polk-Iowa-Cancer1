<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Cancer Trends</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; color: #111; }
    .controls { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
    label { font-weight: 600; margin-right: 6px; }
    select { padding: 6px 8px; border: 1px solid #ccc; border-radius: 8px; font-size: 14px; }
    #chart { width: 100%; height: 680px; }
    .footnote { margin-top: 8px; font-size: 12px; color: #555; }
  </style>
</head>
<body>
  <h2 style="margin-top:0">Cancer Trends</h2>

  <div class="controls">
    <div>
      <label for="sexSel">Sex</label>
      <select id="sexSel"></select>
    </div>
    <div>
      <label for="siteSel">Site</label>
      <select id="siteSel"></select>
    </div>
  </div>

  <div id="chart"></div>
  <div class="footnote">Rates are reported as cancers per 100,000 population.</div>

  <script>
    const DATA_URL = 'data.csv'; // place your CSV next to this file
    const PLOT_HEIGHT_PER_ROW = 320; // auto-scales by number of facet rows
    const FACET_COLS = 2; // two-column facet wrap

    // Helper: sort Year labels numerically but keep as strings
    function sortYears(years) {
      return [...new Set(years)]
        .map(String)
        .sort((a,b) => (parseInt(a,10) || 0) - (parseInt(b,10) || 0));
    }

    // Build color palette mapping for stable colors across facets
    function makeColorMap(values) {
      const palette = Plotly.d3.schemeCategory10 || ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"];
      const uniq = [...new Set(values)];
      const map = new Map();
      uniq.forEach((v, i) => map.set(v, palette[i % palette.length]));
      return map;
    }

    d3.csv(DATA_URL, d3.autoType).then(raw => {
      // Coerce types we rely on
      const data = raw.map(r => ({
        Year: String(r.Year),
        Sex: String(r.Sex),
        Site: String(r.Site),
        Polk: String(r.Polk),
        Group: String(r.Group),
        Cancer: +r.Cancer,  // numeric
        p: r.p === undefined || r.p === null || r.p === '' ? null : +r.p
      }));

      // Populate dropdowns
      const sexSel  = document.getElementById('sexSel');
      const siteSel = document.getElementById('siteSel');

      const sexOptions  = Array.from(new Set(data.map(d => d.Sex))).sort();
      const siteOptions = Array.from(new Set(data.map(d => d.Site))).sort();

      sexOptions.forEach(v => { const o=document.createElement('option'); o.value=o.textContent=v; sexSel.appendChild(o); });
      siteOptions.forEach(v => { const o=document.createElement('option'); o.value=o.textContent=v; siteSel.appendChild(o); });

      sexSel.value  = sexOptions[0] || '';
      siteSel.value = siteOptions[0] || '';

      function render() {
        const sexVal  = sexSel.value;
        const siteVal = siteSel.value;

        const df = data.filter(d => d.Sex === sexVal && d.Site === siteVal && Number.isFinite(d.Cancer));

        const years = sortYears(df.map(d => d.Year));
        const polkLevels = Array.from(new Set(df.map(d => d.Polk)));
        const groupLevels = Array.from(new Set(df.map(d => d.Group)));
        const colorMap = makeColorMap(groupLevels);

        // Subplot grid domains (two columns)
        const rows = Math.ceil(polkLevels.length / FACET_COLS);
        const colWidth = 1 / FACET_COLS;
        const rowHeight = 1 / rows;

        // Map subplot index -> domain + axis ids
        const subplotInfo = polkLevels.map((_, idx) => {
          const r = Math.floor(idx / FACET_COLS);
          const c = idx % FACET_COLS;
          // domain in [0,1]
          const x0 = c * colWidth, x1 = x0 + colWidth;
          // flip vertically: top row has y domain near 1
          const y1 = 1 - r * rowHeight, y0 = y1 - rowHeight;
          return {x:[x0, x1], y:[y0, y1]};
        });

        const traces = [];
        const layout = {
          margin: {l: 70, r: 20, t: 40, b: 10},
          hovermode: 'closest',
          legend: {x: 0.01, y: 0.99, xanchor: 'left', yanchor: 'top', bgcolor: 'rgba(255,255,255,0.7)', title: {text: ''}},
          annotations: [],
          // y-axis title on the leftmost axis only; others match it (shared)
          yaxis: {title: {text: 'Cancer Rate'}, rangemode: 'tozero', showgrid: true, zeroline: false},
        };

        // For each facet (Polk), add a trace per Group
        polkLevels.forEach((polkVal, idx) => {
          const sub = df.filter(d => d.Polk === polkVal);

          // Build axes ids
          const axId = idx === 0 ? '' : String(idx+1); // first axis uses 'xaxis'/'yaxis', others 'xaxis2', 'yaxis2', ...
          const xaxisName = 'xaxis' + axId;
          const yaxisName = 'yaxis' + axId;

          // Link domains and axis props
          layout[xaxisName] = {
            domain: subplotInfo[idx].x,
            type: 'category',
            categoryorder: 'array',
            categoryarray: years,
            title: {text: ''}, // no x-axis title
            tickangle: 0
          };
          layout[yaxisName] = idx === 0 ? layout.yaxis : {matches: 'y', rangemode: 'tozero', showgrid: true, zeroline: false, title: {text: ''}};

          // Facet title as annotation
          layout.annotations.push({
            x: subplotInfo[idx].x[0] + 0.005,
            y: subplotInfo[idx].y[1] - 0.03,
            xref: 'paper', yref: 'paper',
            xanchor: 'left', yanchor: 'top',
            text: polkVal,
            showarrow: false,
            font: {size: 12, color: '#333'}
          });

          // One trace per Group for this facet
          groupLevels.forEach((g, gi) => {
            const gdat = sub
              .filter(d => d.Group === g)
              .sort((a,b) => (parseInt(a.Year,10)||0) - (parseInt(b.Year,10)||0));

            const showLegend = idx === 0; // legend only for first facet
            const trace = {
              type: 'scatter',
              mode: 'lines+markers',
              name: g,
              legendgroup: g,
              showlegend: showLegend,
              x: gdat.map(d => d.Year),
              y: gdat.map(d => d.Cancer),
              customdata: gdat.map(d => d.p),
              hovertemplate:
                'Year=%{x}<br>' +
                'Cancer=%{y:.2f}<br>' +
                'p=%{customdata:.3f}<extra></extra>',
              marker: {size: 6, color: colorMap.get(g)},
              line: {width: 2, color: colorMap.get(g)},
              xaxis: 'x' + axId,
              yaxis: 'y' + axId
            };
            traces.push(trace);
          });
        });

        // Height scales with facet rows
        const plotHeight = Math.max(500, rows * PLOT_HEIGHT_PER_ROW);
        const config = {responsive: true, displaylogo: false};

        Plotly.newPlot('chart', traces, {...layout, height: plotHeight}, config);
      }

      // Initial draw + re-render on selection
      render();
      sexSel.addEventListener('change', render);
      siteSel.addEventListener('change', render);
    });
  </script>
</body>
</html>
